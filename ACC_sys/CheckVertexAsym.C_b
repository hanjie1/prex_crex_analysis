#include "LoadAsym.h"
#include "LoadACC.h"
#include "SetCut.h"

void CheckVertexAsym(){
     double ppb = 1e9;
     double amu_c2 = 0.931494028; // GeV

     TChain *T = new TChain("T");
     T->Add("/lustre19/expphy/volatile/halla/parity/ryanrich/Ebeam953/TargNominal/Zero1_SandwichLHRS_PREX_0.0_1.root");
     T->Add("/lustre19/expphy/volatile/halla/parity/ryanrich/Ebeam953/TargNominal/Zero1_SandwichLHRS_PREX_0.0_2.root");
     T->Add("/lustre19/expphy/volatile/halla/parity/ryanrich/Ebeam953/TargNominal/Zero1_SandwichLHRS_PREX_0.0_3.root");
     T->Add("/lustre19/expphy/volatile/halla/parity/ryanrich/Ebeam953/TargNominal/Zero1_SandwichLHRS_PREX_0.0_4.root");
     T->Add("/lustre19/expphy/volatile/halla/parity/ryanrich/Ebeam953/TargNominal/Zero1_SandwichLHRS_PREX_0.0_5.root");

     TH1F *hpztarg = new TH1F("hpztarg","p_ztarg distribution with cut",200,945,954);
     T->Draw("p_ztarg>>hpztarg",(colCut+isPb+XCUT)*"rate");
     hpztarg->Draw("HIST");

     Int_t pbin = hpztarg->GetMaximumBin();
     Double_t p_peak = hpztarg->GetBinCenter(pbin);
     cout<<"p peak:  "<<p_peak<<endl;

     // dp cut for accepted events
     TString dpcut = Form("(%f-p_ztarg)<2.2",p_peak);
     TCut DP = Form("%s",dpcut.Data());

     // dp cut for the incident events
     double delta_p_percent = 2./100.;
     double delta_p = p_peak*delta_p_percent;

     // final cuts
     TCut ACC = DP+isPb+colCut+XCUT;

     // load acceptance table
     double accp_angle[100]={0}, accp[100]={0}, accp_err[100]={0};
     bool accf_original = false;  // original acceptance function
     TString acc_shape, filename;
     if(accf_original) filename = "accfunction.csv";
     else{
        acc_shape = "gaus";   // box or gaus
        filename = Form("accfunction_%s.csv",acc_shape.Data());
     }
     int status = LoadACC(filename,accp_angle, accp, accp_err);
     if(status==0) exit(0);  // asymmetry table doesn't exist

     bool check_ACC = true; // check mean and rms of acceptance function
     if(check_ACC){
        TH1F *hACC = new TH1F("hACC","acceptance function",100,3,8);

        int check_nbin_th = 100000;
        double dtheta = (8.0-3.0)/(check_nbin_th*1.0);  // delta theta in radius
        for(int ii=0; ii<check_nbin_th; ii++){
          double thisAngle = 3.0 + dtheta*ii;
          double thisACC = FindACC(thisAngle,accp_angle,accp,accp_err,100);  // acceptance to the corresponding angle
          if(thisACC<0) {printf("Something wrong here: ACC= %f\n",thisACC); exit(0);}

          hACC->Fill(thisAngle,thisACC/1000.);
        }

        Double_t mean = hACC->GetMean();
        Double_t RMS = hACC->GetRMS();
        Double_t mean_bin = hACC->FindBin(mean);
        Double_t peak = hACC->GetBinContent(mean_bin);///hACC_N->GetBinContent(mean_bin);;
        cout<<"ACC function peak, mean, rms"<<"  "<<peak<<"  "<<mean<<"  "<<RMS<<endl;
     }
      
     // load asymmetry table
     LoadTable("horpb.dat", 0);

     int nbins=200;
     TH1F *hasym_origin = new TH1F("hasym_origin","vertex asymmetry in g4hrs with ACC cut",nbins,200,1000);
     TH1F *hasym_acc1 = new TH1F("hasym_acc1","vertex asymmetry calculated from acceptance function with dp cut",nbins,200,1000);
     TH1F *hasym_e_acc = new TH1F("hasym_e_acc","elemental asymmetry with acceptance function applied",nbins,200,1000);

     TH1F *hth_origin = new TH1F("hth_origin","vertex theta in g4hrs with ACC cut",100,3,8);
     TH1F *hth_e_acc = new TH1F("hth_e_acc","elemental theta with acceptance function applied",100,3,8);

     TH1F *hq2_origin = new TH1F("hq2_origin","vertex Q2 in g4hrs with ACC cut",100,0,0.015);
     TH1F *hq2_e_acc = new TH1F("hq2_e_acc","elemental Q2 with acceptance function applied",100,0,0.015);

     T->Draw("ev.A>>hasym_origin",ACC*"rate");   // vertex asymmetry calculated in g4hrs with acceptance cuts applied
     T->Draw("ev.Th>>hth_origin",ACC*"rate");   // vertex theta calculated in g4hrs with acceptance cuts applied
     T->Draw("ev.Q2>>hq2_origin",ACC*"rate");   // vertex Q2 calculated in g4hrs with acceptance cuts applied

     double thisBeamE,thisTh,thisRate,p_ztarg,xfp;
     int thisA;
     T->SetBranchAddress("ev.Th",&thisTh);
     T->SetBranchAddress("ev.beamp",&thisBeamE);
     T->SetBranchAddress("ev.nuclA",&thisA);
     T->SetBranchAddress("rate",&thisRate);
     T->SetBranchAddress("p_ztarg",&p_ztarg);
     T->SetBranchAddress("x_fp_tr",&xfp);

     Double_t nentries = T->GetEntries();
     for(int ii=0; ii<nentries; ii++){
        T->GetEntry(ii);

	double thisAsym = Interpolate(thisBeamE,thisTh,0,1);  // vertex asymmetry (should be the same as ev.A)
	double thisACC = FindACC(thisTh,accp_angle,accp,accp_err,100);  // acceptance to the corresponding angle

	if(thisACC<0) {printf("Something wrong here: ACC= %f\n",thisACC); exit(0);}

	if( thisA==208 && (p_peak-p_ztarg)<delta_p) hasym_acc1->Fill(thisAsym*ppb,thisRate*thisACC);
     }

     double setBeamE = 0.9534; 
     int nbin_th = 10000;
     double dtheta = (8.0-3.0)/(nbin_th*1.0);  // delta theta in radius

     for(int ii=0; ii<nbin_th; ii++){
	double thisAngle = 3.0 + dtheta*ii;
	double thisAsym = Interpolate(setBeamE,thisAngle,0,1);  // elemental asymmetry
	double thisXS = Interpolate(setBeamE,thisAngle,0,0);  // elemental cross section

	double deg_to_rad = TMath::Pi()/180.;
	double thisEp = setBeamE/(1.+setBeamE/(208.*amu_c2)*(1.-TMath::Cos(thisAngle*deg_to_rad)));
	double thisQ2 = 4.*setBeamE*thisEp*pow(TMath::Sin(thisAngle*deg_to_rad/2.),2);

	double thisACC = FindACC(thisAngle,accp_angle,accp,accp_err,100);  // acceptance to the corresponding angle
	if(thisACC<0) {printf("Something wrong here: ACC= %f\n",thisACC); exit(0);}

	double omega = TMath::Sin(thisAngle*deg_to_rad)*dtheta*deg_to_rad;
	hasym_e_acc->Fill(thisAsym*ppb,thisXS*omega*thisACC);   // elemetal asymmetry with the acceptance function applied
	hth_e_acc->Fill(thisAngle,thisXS*omega*thisACC);   // elemetal angle with the acceptance function applied
	hq2_e_acc->Fill(thisQ2,thisXS*omega*thisACC);   // elemetal Q2 with the acceptance function applied
     } 

     cout<<"================================="<<endl;
     cout<<"orignal vertex asymmetry mean:     "<<setw(8)<<hasym_origin->GetMean()<<"   "<<"RMS:  "<<setw(8)<<hasym_origin->GetRMS()<<endl;
     cout<<"reproduce vertex asymmetry mean:   "<<setw(8)<<hasym_acc1->GetMean()<<"   "<<"RMS:  "<<setw(8)<<hasym_acc1->GetRMS()<<endl;
     cout<<"elemental asymmetry mean:          "<<setw(8)<<hasym_e_acc->GetMean()<<"   "<<"RMS:  "<<setw(8)<<hasym_e_acc->GetRMS()<<endl;
     cout<<"================================="<<endl;
     cout<<"orignal vertex angle mean:   "<<setw(8)<<hth_origin->GetMean()<<"   "<<"RMS:  "<<setw(8)<<hth_origin->GetRMS()<<endl;
     cout<<"elemental angle mean:        "<<setw(8)<<hth_e_acc->GetMean()<<"   "<<"RMS:  "<<setw(8)<<hth_e_acc->GetRMS()<<endl;
     cout<<"================================="<<endl;
     cout<<"orignal vertex Q2 mean:   "<<setw(8)<<hq2_origin->GetMean()<<"   "<<"RMS:  "<<setw(8)<<hq2_origin->GetRMS()<<endl;
     cout<<"elemental Q2 mean:        "<<setw(8)<<hq2_e_acc->GetMean()<<"   "<<"RMS:  "<<setw(8)<<hq2_e_acc->GetRMS()<<endl;
     cout<<"================================="<<endl;

     Double_t inte1 = hasym_origin->GetMaximum();
     Double_t inte2 = hasym_e_acc->GetMaximum();
     Double_t inte3 = hasym_acc1->GetMaximum();
     hasym_e_acc->Scale(inte1/inte2);
     //hasym_acc1->Scale(inte1/inte3);

     TCanvas *c1 = new TCanvas("c1","c1",1500,1500);
     hasym_origin->SetLineColor(1);
     hasym_acc1->SetLineColor(6);
     hasym_e_acc->SetLineColor(2);

     hasym_origin->SetLineWidth(2);
     hasym_acc1->SetLineWidth(2);
     hasym_e_acc->SetLineWidth(2);

     if(inte1>inte3){
       hasym_origin->Draw("HIST");    
       hasym_acc1->Draw("HIST sames");    
       hasym_e_acc->Draw("HIST sames");
       hasym_origin->SetTitle("Asymmetry with acceptance; asym(ppb)");
     }
     else{
       hasym_acc1->Draw("HIST");    
       hasym_origin->Draw("HIST sames");    
       hasym_e_acc->Draw("HIST sames");
       hasym_acc1->SetTitle("Asymmetry with acceptance; asym(ppb)");
     }

     TLegend *leg = new TLegend(0.15,0.65,0.35,0.8);
     leg->AddEntry(hasym_origin,"origin","L");
     leg->AddEntry(hasym_acc1,Form("reproduce (dp_inc/p=%.3f)",delta_p_percent),"L");
     leg->AddEntry(hasym_e_acc,"elemental","L");
     leg->Draw();

   gPad->Update();
   TPaveStats* statA1 = (TPaveStats*)hasym_origin->FindObject("stats");
   TPaveStats* statA2 = (TPaveStats*)hasym_acc1->FindObject("stats");
   TPaveStats* statA3 = (TPaveStats*)hasym_e_acc->FindObject("stats");
   statA1->SetY1NDC(0.90);
   statA1->SetY2NDC(0.75);
   statA2->SetY1NDC(0.75);
   statA2->SetY2NDC(0.60);
   statA3->SetY1NDC(0.60);
   statA3->SetY2NDC(0.45);
   statA1->SetTextColor(1);
   statA2->SetTextColor(6);
   statA3->SetTextColor(2);
   gPad->Modified();

     TLatex tex1;
     tex1.SetTextAlign(11);
     tex1.SetTextSize(0.02);
     if(accf_original) tex1.DrawLatexNDC(0.75,0.5,"original acceptance");
     else tex1.DrawLatexNDC(0.65,0.3,Form("%s acceptance",acc_shape.Data()));
    
     inte1 = hth_origin->GetMaximum();
     inte2 = hth_e_acc->GetMaximum();
     hth_e_acc->Scale(inte1/inte2);

     TCanvas *c2 = new TCanvas("c2","c2",1500,1500);
     c2->Divide(2,1);
     c2->cd(1);
     hth_origin->SetLineColor(1);
     hth_e_acc->SetLineColor(2);

     hth_origin->SetLineWidth(2);
     hth_e_acc->SetLineWidth(2);

     hth_origin->Draw("HIST");    
     hth_e_acc->Draw("HIST same");
     hth_origin->SetTitle("angle with acceptance; angle");

     TLegend *leg1 = new TLegend(0.65,0.65,0.8,0.8);
     leg1->AddEntry(hth_origin,"origin","L");
     leg1->AddEntry(hth_e_acc,"elemental","L");
     leg1->Draw();
    
     c2->cd(2);
     inte1 = hq2_origin->GetMaximum();
     inte2 = hq2_e_acc->GetMaximum();
     hq2_e_acc->Scale(inte1/inte2);

     hq2_origin->SetLineColor(1);
     hq2_e_acc->SetLineColor(2);

     hq2_origin->SetLineWidth(2);
     hq2_e_acc->SetLineWidth(2);

     hq2_origin->Draw("HIST");    
     hq2_e_acc->Draw("HIST same");
     hq2_origin->SetTitle("Q2 with acceptance; Q2");

     TLegend *leg2 = new TLegend(0.15,0.65,0.35,0.8);
     leg2->AddEntry(hq2_origin,"origin","L");
     leg2->AddEntry(hq2_e_acc,"elemental","L");
     leg2->Draw();
    
     TLatex tex2;
     tex2.SetTextAlign(11);
     tex2.SetTextSize(0.03);
     if(accf_original) tex2.DrawLatexNDC(0.75,0.5,"original acceptance");
     else tex2.DrawLatexNDC(0.65,0.5,Form("%s acceptance",acc_shape.Data()));

}
